# Мапа програмної архітектури

# Резюме

Складність взаємопов’язаної та різнорідної веб-інфраструктури може включати сотні веб-додатків і робить керування
конфігурацією та перегляд фундаментальним кроком у тестуванні та розгортанні кожної окремої програми. Насправді потрібна
лише одна вразливість, щоб підірвати безпеку всієї інфраструктури, і навіть невеликі та, здавалося б, неважливі проблеми
можуть перетворитися на серйозні ризики для іншої програми в тій самій інфраструктурі.

Щоб вирішити ці проблеми, надзвичайно важливо виконати поглиблений аналіз конфігурації та відомих проблем безпеки. Перед
виконанням поглибленого огляду необхідно відобразити мережу та архітектуру програми. Необхідно визначити різні елементи,
що складають інфраструктуру, щоб зрозуміти, як вони взаємодіють із веб-додатком і як впливають на безпеку.

# Цілі тесту

- Створіть карту поточної програми на основі проведеного дослідження.

# Як тестувати

## Відобразити архітектуру програми

Архітектуру програми потрібно відобразити за допомогою певного тесту, щоб визначити, які різні компоненти
використовуються для створення веб-програми. У невеликих налаштуваннях, таких як проста програма PHP, може
використовуватися один сервер, який обслуговує програму PHP і, можливо, також механізм автентифікації.

У більш складних налаштуваннях, таких як система онлайн-банку, може бути задіяно кілька серверів. Вони можуть включати
зворотний проксі-сервер, зовнішній веб-сервер, сервер додатків і сервер бази даних або сервер LDAP. Кожен із цих
серверів використовуватиметься для різних цілей і навіть може бути відокремлений у різних мережах з брандмауерам між
ними. Це створює різні мережеві зони, щоб доступ до веб-сервера не обов’язково надавав віддаленому користувачеві доступ
до самого механізму автентифікації, і щоб компрометації різних елементів архітектури могли бути ізольовані, щоб вони не
скомпрометували всю архітектуру.

Отримати знання про архітектуру програми може бути легко, якщо цю інформацію надають групі тестувальників розробники
програми у формі документа або під час співбесід, але також може виявитися дуже складно, якщо проводити сліпий тест на
проникнення.

В останньому випадку тестувальник спочатку почне з припущення про просте налаштування (один сервер). Потім вони
отримають інформацію з інших тестів і виведуть різні елементи, поставлять під сумнів це припущення та розширять карту
архітектури. Тестер почне з простих запитань, наприклад: «Чи існує брандмауер, який захищає веб-сервер?». Відповідь на
це запитання буде надано на основі результатів мережевого сканування, націленого на веб-сервер, і аналізу того, чи
фільтруються мережеві порти веб-сервера на межі мережі (немає відповіді або ICMP недоступні), чи сервер є безпосередньо
підключений до Інтернету (тобто повертає пакети RST для всіх портів, які не прослуховуються). Цей аналіз можна
розширити, щоб визначити тип використовуваного брандмауера на основі тестів мережевих пакетів. Це брандмауер із
спостереженням за станом чи це фільтр списку доступу на маршрутизаторі? Як це налаштовано? Чи можна це обійти? Це
повноцінний брандмауер веб-додатків?

Виявлення зворотного проксі-сервера перед веб-сервером можна здійснити за допомогою аналізу банера веб-сервера, який
може безпосередньо виявити існування зворотного проксі-сервера. Його також можна визначити, отримавши відповіді, надані
веб-сервером на запити, і порівнявши їх з очікуваними відповідями. Наприклад, деякі зворотні проксі діють як системи
запобігання вторгненням (IPS), блокуючи відомі атаки, спрямовані на веб-сервер. Якщо відомо, що веб-сервер відповідає
повідомленням 404 на запит, спрямований на недоступну сторінку, і повертає інше повідомлення про помилку для деяких
поширених веб-атак, таких як ті, що виконуються сканерами вразливостей, це може бути ознакою зворотного проксі (або
брандмауер на рівні програми), який фільтрує запити та повертає сторінку помилки, відмінну від очікуваної. Інший
приклад: якщо веб-сервер повертає набір доступних методів HTTP (включаючи TRACE), але очікувані методи повертають
помилки, тоді, ймовірно, існує щось середнє між їх блокуванням.

У деяких випадках навіть система захисту видає себе. Ось приклад самоідентифікації mod_security:

![](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/images/10_mod_security.jpg)

Зворотні проксі-сервери також можуть бути представлені як проксі-кеші для прискорення продуктивності внутрішніх серверів
додатків. Виявлення цих проксі можна зробити на основі заголовка сервера. Їх також можна виявити шляхом визначення часу
запитів, які сервер має кешувати, і порівняння часу, витраченого на сервер першого запиту з наступними запитами.

Іншим елементом, який можна виявити, є балансувальники мережевого навантаження. Як правило, ці системи збалансують
заданий порт TCP/IP для кількох серверів на основі різних алгоритмів (циклічний, завантаження веб-сервера, кількість
запитів тощо). Таким чином, виявлення цього елемента архітектури має здійснюватися шляхом вивчення кількох запитів і
порівняння результатів, щоб визначити, чи надходять запити до одного чи різних веб-серверів. Наприклад, на основі
заголовка Date, якщо годинники сервера не синхронізовані. У деяких випадках процес балансування мережевого навантаження
може вставляти нову інформацію в заголовки, що виразно виділятиме його, наприклад файл cookie з префіксом BIGipServer,
представлений балансувальниками навантаження F5 BIG-IP.

Веб-сервери програм зазвичай легко виявити. Запит на кілька ресурсів обробляється самим сервером додатків (а не
веб-сервером), і заголовок відповіді буде суттєво відрізнятися (включаючи різні або додаткові значення в заголовку
відповіді). Інший спосіб їх виявити — перевірити, чи намагається веб-сервер встановити файли cookie, які вказують на
використання веб-сервера програми (наприклад, JSESSIONID, наданий різними серверами J2EE), або автоматично переписати
URL-адреси для відстеження сеансу.

Однак сервери автентифікації (такі як каталоги LDAP, реляційні бази даних або сервери RADIUS) не так легко виявити з
зовнішньої точки зору одразу, оскільки вони будуть приховані самою програмою.

Використання внутрішньої бази даних можна визначити просто за допомогою навігації додатком. Якщо дуже динамічний вміст
створюється «на льоту», він, імовірно, витягується з якоїсь бази даних самою програмою. Іноді спосіб запиту інформації
може дати розуміння існування серверної частини бази даних. Наприклад, додаток для онлайн-покупок, який використовує
числові ідентифікатори (id) під час перегляду різних статей у магазині. Однак під час сліпого тестування програми
відомості про базову базу даних зазвичай доступні лише тоді, коли в програмі з’являється вразливість, наприклад погана
обробка винятків або чутливість до впровадження SQL.

